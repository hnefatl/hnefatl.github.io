<!doctype html><html lang=en><head><title>Not so "local" sites ::
keith's blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="When configuring a home network with locally-hosted services, it&amp;rsquo;s common to use a reverse-proxy to provide easy-to-remember names for all your local sites. But can that reverse proxy be abused to provide external attackers access to your internal sites?
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.keith.collister.xyz/posts/local_site_vulnerability/><link rel=stylesheet href=https://blog.keith.collister.xyz/assets/style.css><link rel=stylesheet href=https://blog.keith.collister.xyz/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://blog.keith.collister.xyz/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://blog.keith.collister.xyz/img/favicon.png><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://blog.keith.collister.xyz/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Not so &#34;local&#34; sites"><meta name=twitter:description content="When configuring a home network with locally-hosted services, it&rsquo;s common to use a reverse-proxy to provide easy-to-remember names for all your local sites. But can that reverse proxy be abused to provide external attackers access to your internal sites?"><meta property="og:title" content="Not so &#34;local&#34; sites"><meta property="og:description" content="When configuring a home network with locally-hosted services, it&rsquo;s common to use a reverse-proxy to provide easy-to-remember names for all your local sites. But can that reverse proxy be abused to provide external attackers access to your internal sites?"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.keith.collister.xyz/posts/local_site_vulnerability/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-16T20:16:12+02:00"><meta property="article:modified_time" content="2022-04-16T20:16:12+02:00"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>keith's blog</span>
<span class=logo__cursor></span></a>
<span class=header__right><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Not so &ldquo;local&rdquo; sites</h1><div class=post-meta><span class=post-date>2022-04-16</span>
<span class=post-read-time>â€” 5 min read</span></div><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#the-vulnerability>The vulnerability</a></li><li><a href=#solutions>Solutions</a></li></ul></nav></aside><p>When configuring a home network with locally-hosted services, it&rsquo;s common to use a reverse-proxy to provide easy-to-remember names for all your local sites. But can that reverse proxy be abused to provide external attackers access to your internal sites?</p><h2 id=background>Background
<a href=#background class=h-anchor aria-hidden=true>#</a></h2><p>A typical home network setup with locally-hosted services (e.g. <a href=https://adguard.com>AdGuard</a> or <a href=https://www.home-assistant.io>Home Assistant</a>) might contain a reverse proxy to handle some custom addresses so that:</p><ul><li><a href=http://router.lan>http://router.lan</a> redirects to your router</li><li><a href=http://server.lan>http://server.lan</a> points to your home server</li><li><a href=https://foo.my-domain.net>https://foo.my-domain.net</a> points to some service running on your network which you want to be able to access while out and about. I&rsquo;ll use <a href=https://www.plex.tv>Plex</a> in examples below, since it&rsquo;s a common usecase for a local server.</li></ul><p>The configuration might look something like (using Caddy syntax since it&rsquo;s very readable):</p><pre tabindex=0><code>// Internal-only sites/convenient redirects
http://router.lan {
    reverse_proxy 192.168.1.1:80
}
http://server.lan {
    reverse_proxy 192.168.1.5:7800
}

// Public site
https://plex.my-domain.net, http://plex.lan {
    reverse_proxy 192.168.1.5:32400
}
</code></pre><details><summary>More detailed explanation</summary><p>Somewhat out-of-scope of this post, but some additional background on how these local services are normally configured might be useful here.</p><ul><li>A local server (e.g. raspberry pi, unraid machine) is given a static IP (above, <code>192.168.1.5</code>) and hosts a number of services, e.g.:<ul><li>some admin interface, often a webserver allowing for remote control, listening on a nonstandard port (above, <code>7800</code>).</li><li>a plex server, which binds to port <code>32400</code>.</li><li>the reverse proxy itself (in the above example, a caddy server). This service binds to ports <code>80</code> and <code>443</code> on the server: when hit with a request for e.g. <a href=http://router.lan>http://router.lan</a>, it will forward the traffic to the configured internal host (in this case <code>192.168.1.1</code>).</li></ul></li><li>DNS servers are configured such that:<ul><li>external (public) DNS servers route <code>my-domain.net</code> to the public IP address of the router. This allows external clients to look up <code>plex.my-domain-net</code> and hit the local router&rsquo;s external interface, so it can proxy to the internal service (see the router section below).</li><li>internal DNS servers (often just the DNS settings on the router) route <code>*.lan</code> to the server running our services. This allows internal clients using the &ldquo;internal&rdquo; addresses like <a href=https://router.lan>https://router.lan</a> to resolve the server.</li></ul></li><li>The router is configured to:<ul><li>route all http/https traffic hitting the external interface on ports <code>80</code>/<code>443</code> to the server running the reverse proxy (<code>192.168.1.5</code>). This is &ldquo;port-forwarding&rdquo; in IPv4 parlance.</li></ul></li></ul><p>Let&rsquo;s trace a request to see why all the above steps are necessary. An internal client requests <a href=http://router.lan>http://router.lan</a>:</p><ol><li>the client&rsquo;s DNS resolver contacts the router to resolve <code>router.lan</code>.</li><li>the router returns the server&rsquo;s IP (<code>192.168.1.5</code>).</li><li>the client opens an http connection to <code>192.168.1.5:80</code> requesting the domain <code>router.lan</code>.</li><li>the reverse proxy webserver is listening on <code>192.168.1.5:80</code>, so looks up <code>router.lan</code> in its configuration and finds <code>192.168.1.1:80</code>: it then proxies the client&rsquo;s request to that address (the router&rsquo;s web interface).</li><li>the client sees the router&rsquo;s web interface.</li></ol><p>A request from an external client is very similar, just with a slightly different route into the network. For a request to <a href=https://plex.my-domain.net>https://plex.my-domain.net</a>:</p><ol><li>the client&rsquo;s DNS resolver contacts a public DNS to resolve <code>plex.my-domain.net</code>.</li><li>the public DNS returns our router&rsquo;s public IP.</li><li>the client sends an http request to the router&rsquo;s public IP requesting domain <a href=https://plex.my-domain.net>https://plex.my-domain.net</a>.</li><li>the router port-forwards the request to our server (<code>192.168.1.5</code>), and we&rsquo;re in a very similar place to the end of step 3 in the above internal example.</li><li>as above starting from step 4.</li></ol></details><p>This works great! Internal clients can access internal sites like <a href=http://router.lan>http://router.lan</a>, and external clients can access our &ldquo;deemed public&rdquo; sites like <a href=https://plex.my-domain.net>https://plex.my-domain.net</a>. Internal clients can even use the external address and we should resolve the site correctly.</p><p>And external clients can&rsquo;t access our internal sites, since for anything outside our network the <code>*.local</code> domains won&rsquo;t resolve to our server. Right? Wrong.</p><h2 id=the-vulnerability>The vulnerability
<a href=#the-vulnerability class=h-anchor aria-hidden=true>#</a></h2><p>In a nutshell, the vulnerability is that external clients can <em>force</em> an arbitrary domain name to resolve to a specific IP. The most common method for doing this is adding an entry in <code>/etc/hosts</code>, like:</p><pre tabindex=0><code>&lt;victim&#39;s router&#39;s public IP&gt; router.lan
</code></pre><p>An easier-to-test method is to provide a DNS resolution override to <code>curl</code>, e.g.:</p><pre tabindex=0><code>$ curl --resolve router.lan:80:&lt;victim&#39;s router&#39;s public IP&gt; router.lan
</code></pre><p>This forces the request to hit your router with an internal domain name, which will proxy the attacker through to your internal sites.</p><p>This attack vector relies on the attacker knowing both your network&rsquo;s public IP (not hard to obtain if you&rsquo;re hosting other public sites) and the internal domain names you use. The internal domain names are easy to dictionary-attack, since the primary purpose is to be memorable for humans.</p><h2 id=solutions>Solutions
<a href=#solutions class=h-anchor aria-hidden=true>#</a></h2><p>Most reverse proxies provide a way of allowlisting only certain IP ranges. For the cider example above, we can tweak our internal sites to use <a href=https://caddyserver.com/docs/caddyfile/matchers#remote-ip><code>remote_ip</code></a>:</p><pre tabindex=0><code>http://server.lan {
    // Only allow internal clients.
    remote_ip 192.168.0.0/16

    reverse_proxy 192.168.1.5:7800
}
</code></pre><p>A more bulletproof (paranoid?) solution is to configure an authentication backend that sits between your reverse proxy and any sites being proxied to, such as <a href=https://github.com/authelia/authelia>Authelia</a>. This is what I ended up switching to after realising this vulnerability on my own setup.</p><p>With this, before the reverse proxy proxies any requests, it&rsquo;ll verify the client is authenticated+authorised (and redirect them to the authentication portal if not). The only way to bypass this is to hit the raw IP directly rather than using an address (which should only be possible for devices already on the local network).</p><p>Although it sounds unwieldy, this &ldquo;full&rdquo; solution is very low-friction. Devices only need to login once then are authenticated for a long duration (I think 30d by default). For clients which are on the local network you can require only a password to login, making the monthly refresh quick and easy. For external clients you can additionally require 2FA, which is suitable for the occasional times one needs to log in from a remote device for the first time.</p></div></div></div><script src=https://blog.keith.collister.xyz/assets/main.js></script>
<script src=https://blog.keith.collister.xyz/assets/prism.js></script></div></body></html>